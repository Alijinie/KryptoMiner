<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CRYPTO-MINE</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: 'Inter', sans-serif;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="rgba(0, 255, 128, 0.9)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>') 12 12, auto;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display: block;
            color: rgba(0, 255, 128, 0.9);
            font-size: 1.1em;
            text-shadow: 0 0 5px rgba(0, 255, 128, 0.7);
            opacity: 1;
            transition: opacity 0.5s;
        }
        .hud {
            position: absolute;
            color: rgba(0, 255, 128, 0.9);
            font-family: 'Courier New', monospace;
            font-size: 14px;
            text-shadow: 0 0 8px rgba(0, 255, 128, 1);
            pointer-events: none;
        }
        #hud-container {
            position: absolute;
            top: 20px;
            width: device-width;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 100;
        }
        #hud-bottom-right {
            bottom: 20px;
            right: 20px;
            text-align: right;
            z-index: 100;
        }
        #warpButton {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: rgba(0, 255, 128, 0.1);
            border: 1px solid rgba(0, 255, 128, 0.7);
            color: rgba(0, 255, 128, 0.9);
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            text-transform: uppercase;
            transition: background 0.3s, color 0.3s, transform 0.3s;
            z-index: 101;
        }
        #warpButton:hover {
            background: rgba(0, 255, 128, 0.9);
            color: #000;
            transform: translateX(-50%) scale(1.05);
        }
        #scan-coords {
            opacity: 0;
            transition: opacity 0.5s;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(0, 255, 128, 0.9);
            font-size: 1.5em;
            text-shadow: 0 0 5px rgba(0, 255, 128, 0.7);
            z-index: 102;
            display: none;
        }

        /* Mobile-specific adjustments */
        @media (max-width: 600px) {
            #info {
                font-size: 0.9em;
                top: 5px;
            }
            #hud-container {
                top: 40px;
            }
            .hud {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <audio id="background-music" src="/audio/soundtrack.mp3" loop preload="auto"></audio>
    <div id="info"><dAPP-1S>$SOLANA</dAPP-1S> | ICO: dAPP | START MINE: ENGAGE WARP | CASHOUT: OPay | MINE NAIRA-COIN</div>
    <div id="hud-container">
        <div id="hud-top-left" class="hud">
          <section>
            <p>STATUS: NOMINAL</p>
            <p>WALLET: NOT CONNECTED</p>
            <p>MINING RATE: <span id="mining-rate">0.10</span> ₦/s</p>
          </section>
        </div>
        <div id="hud-top-right" class="hud">
            <p>NAIRA-COIN: <span id="naira-coin">0.00</span></p>
        </div>
    </div>
    <div id="hud-bottom-right" class="hud">
        <p>ORBITAL VELOCITY: 7.67 km/s</p>
        <p id="scan-coords">: --.----, --.----</p>
    </div>
    <button id="warpButton">START MINE</button>
    <div id="loading">Initializing Warp Core...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/",
                "three/addons/shaders/RGBShiftShader.js": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/shaders/RGBShiftShader.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { RGBShiftShader } from 'three/addons/shaders/RGBShiftShader.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';


        let scene, camera, renderer, controls, composer;
        let earthMesh, cloudMesh, glowMesh, starField, satelliteGroup, nairaSignsGroup;
        let raycaster, mouse = new THREE.Vector2();
        let isWarping = false;
        let warpSpeed = 0;
        let audioContext, scanSound, warpSound, bgMusic;
        let rgbShiftPass;
        let hexGridMesh;
        let particleSystem;
        let nairaCoin = 0;
        let miningRate = 0.1;
        let audioInitialized = false;

        const bloomParams = {
            strength: 0.8,
            radius: 0.6,
            threshold: 0.05
        };

        function init() {
            document.getElementById('loading').style.display = 'block';

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 4000);
            camera.position.z = 1.5;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            setupLighting();
            createStarfield();
            createEarth();
            createHexGrid();
            createGlowShield();
            createSatellites();
            createNairaSigns();
            createWarpParticles();
            setupPostProcessing();
            setupControls();
            setupInteractivity();

            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
            }, 1000);

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('keydown', onKeyDown);
        }

        // Removed initAudio from the original logic as the HTML audio tag handles this.

        function playBackgroundMusic() {
            const bgMusic = document.getElementById('background-music');
            if (bgMusic) {
                bgMusic.play().catch(e => console.error("Error playing background music:", e));
            }
        }

        function playScanSound() {
            // This function is now empty to disable the scan sound.
            // The original code has been commented out to prevent it from playing.
            /*
            if (!audioInitialized) return;
            const gain = audioContext.createGain();
            gain.gain.setValueAtTime(0.5, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);
            scanSound.connect(gain).connect(audioContext.destination);
            setTimeout(() => scanSound.disconnect(gain), 500);
            */
        }

        function updateWarpSound() {
            if (!audioInitialized) return;
            // Set the gain to 0 to permanently mute the warp sound.
            const gain = audioContext.createGain();
            gain.gain.value = 0;
            warpSound.connect(gain).connect(audioContext.destination);
        }


        function setupLighting() {
            scene.add(new THREE.AmbientLight(0xffffff, 0.3));
            const sunLight = new THREE.DirectionalLight(0xffffff, 2.0);
            sunLight.position.set(-2, 0.5, 1.5);
            scene.add(sunLight);
            const techLight = new THREE.PointLight(0x00ff80, 4.0, 20);
            techLight.position.set(2, 2, 2);
            scene.add(techLight);
        }

        function createStarfield() {
            const starVertices = [];
            for (let i = 0; i < 50000; i++) {
                const x = THREE.MathUtils.randFloatSpread(4000);
                const y = THREE.MathUtils.randFloatSpread(4000);
                const z = THREE.MathUtils.randFloatSpread(4000);
                starVertices.push(x, y, z);
            }
            const starGeometry = new THREE.BufferGeometry();
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.9, transparent: true, opacity: 0.7 });
            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }

        function createEarth() {
            const textureLoader = new THREE.TextureLoader();
            const earthGeometry = new THREE.SphereGeometry(0.6, 128, 128);
            const earthMaterial = new THREE.MeshStandardMaterial({
                map: textureLoader.load('https://raw.githubusercontent.com/turban/webgl-earth/master/images/2_no_clouds_4k.jpg'),
                normalMap: textureLoader.load('https://raw.githubusercontent.com/turban/webgl-earth/master/images/water_4k.png'),
                roughnessMap: textureLoader.load('https://raw.githubusercontent.com/turban/webgl-earth/master/images/elev_bump_4k.jpg'),
                roughness: 0.8,
                metalness: 0.1,
                emissiveMap: textureLoader.load('https://raw.githubusercontent.com/turban/webgl-earth/master/images/earth_lights_4k.jpg'),
                emissive: 0xffffff,
                emissiveIntensity: 1.2
            });
            earthMesh = new THREE.Mesh(earthGeometry, earthMaterial);
            scene.add(earthMesh);

            const cloudGeometry = new THREE.SphereGeometry(0.61, 128, 128);
            const cloudMaterial = new THREE.MeshStandardMaterial({
                map: textureLoader.load('https://raw.githubusercontent.com/turban/webgl-earth/master/images/fair_clouds_4k.png'),
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending,
                alphaMap: textureLoader.load('https://raw.githubusercontent.com/turban/webgl-earth/master/images/fair_clouds_4k.png')
            });
            cloudMesh = new THREE.Mesh(cloudGeometry, cloudMaterial);
            scene.add(cloudMesh);
        }

        function createHexGrid() {
            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;
            const fragmentShader = `
                varying vec2 vUv;
                uniform float time;
                float hexDist(vec2 p) {
                    p = abs(p);
                    return max(dot(p, vec2(0.5, 0.866)), p.x) - 0.5;
                }
                void main() {
                    vec2 uv = (vUv - 0.5) * 20.0;
                    float dist = hexDist(fract(uv) - 0.5);
                    float glow = smoothstep(0.05, 0.0, dist) * 0.2;
                    glow += sin(time + vUv.x * 10.0 + vUv.y * 5.0) * 0.05;
                    gl_FragColor = vec4(0.0, 1.0, 0.5, glow);
                }
            `;
            const hexMaterial = new THREE.ShaderMaterial({
                vertexShader,
                fragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.FrontSide,
                uniforms: {
                    time: { value: 0.0 }
                }
            });
            const hexGeometry = new THREE.SphereGeometry(0.62, 64, 64);
            hexGridMesh = new THREE.Mesh(hexGeometry, hexMaterial);
            scene.add(hexGridMesh);
        }

        function createGlowShield() {
            const vertexShader = `
                uniform float time;
                varying vec3 vNormal;
                varying float flareIntensity;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    float pulse = 0.95 + 0.05 * sin(time * 3.0);
                    flareIntensity = 0.0;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position * pulse, 1.0);
                }
            `;
            const fragmentShader = `
                uniform float flare;
                varying vec3 vNormal;
                void main() {
                    float intensity = pow(0.4 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 3.0);
                    intensity += flare * 0.7;
                    gl_FragColor = vec4(0.0, 1.0, 0.5, 1.0) * intensity;
                }
            `;
            const glowMaterial = new THREE.ShaderMaterial({
                vertexShader,
                fragmentShader,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                uniforms: {
                    flare: { value: 0.0 },
                    time: { value: 0.0 }
                }
            });
            const glowGeometry = new THREE.SphereGeometry(0.68, 128, 128);
            glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
            glowMesh.scale.set(1.2, 1.2, 1.2);
            scene.add(glowMesh);
        }

        function createSatellites() {
            satelliteGroup = new THREE.Group();
            for (let i = 0; i < 5; i++) {
                const satGeometry = new THREE.BoxGeometry(0.02, 0.05, 0.02);
                const satMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9, roughness: 0.1 });
                const sat = new THREE.Mesh(satGeometry, satMaterial);
                sat.userData.orbitSpeed = THREE.MathUtils.randFloat(0.1, 0.3);
                sat.userData.orbitRadius = THREE.MathUtils.randFloat(0.9, 1.2);
                sat.userData.phase = THREE.MathUtils.randFloat(0, Math.PI * 2);
                satelliteGroup.add(sat);
            }
            scene.add(satelliteGroup);
        }

        function createNairaSigns() {
            nairaSignsGroup = new THREE.Group();
            const fontLoader = new FontLoader();
            fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {
                const material = new THREE.MeshStandardMaterial({
                    color: 0x00ff80,
                    emissive: 0x00ff80,
                    emissiveIntensity: 0.8,
                    metalness: 0.9,
                    roughness: 0.1
                });

                for (let i = 0; i < 15; i++) {
                    const geometry = new TextGeometry('₦', {
                        font: font,
                        size: 0.08,
                        depth: 0.02,
                        curveSegments: 12,
                        bevelEnabled: true,
                        bevelThickness: 0.005,
                        bevelSize: 0.003,
                        bevelOffset: 0,
                        bevelSegments: 5
                    });
                    const nairaSign = new THREE.Mesh(geometry, material);
                    nairaSign.geometry.center();

                    const radius = THREE.MathUtils.randFloat(1.5, 2.0);
                    const angle = THREE.MathUtils.randFloat(0, Math.PI * 2);
                    nairaSign.position.x = Math.cos(angle) * radius;
                    nairaSign.position.z = Math.sin(angle) * radius;
                    nairaSign.position.y = THREE.MathUtils.randFloatSpread(1.0);

                    nairaSign.userData.orbitSpeed = THREE.MathUtils.randFloat(0.5, 1.0);
                    nairaSign.userData.orbitRadius = radius;
                    nairaSign.userData.phase = angle;
                    
                    nairaSignsGroup.add(nairaSign);
                }
                scene.add(nairaSignsGroup);
            });
        }

        function createWarpParticles() {
            const particles = 1000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particles * 3);
            const velocities = new Float32Array(particles * 3);
            for (let i = 0; i < particles; i++) {
                positions[i * 3] = THREE.MathUtils.randFloatSpread(10);
                positions[i * 3 + 1] = THREE.MathUtils.randFloatSpread(10);
                positions[i * 3 + 2] = THREE.MathUtils.randFloatSpread(10);
                velocities[i * 3] = 0;
                velocities[i * 3 + 1] = 0;
                velocities[i * 3 + 2] = -THREE.MathUtils.randFloat(5, 20);
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05, transparent: true, opacity: 0 });
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

        function setupPostProcessing() {
            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = bloomParams.threshold;
            bloomPass.strength = bloomParams.strength;
            bloomPass.radius = bloomParams.radius;

            rgbShiftPass = new ShaderPass(RGBShiftShader);
            rgbShiftPass.uniforms.amount.value = 0.001;

            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);
            composer.addPass(rgbShiftPass);
        }

        function setupControls() {
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.08;
            controls.minDistance = 0.8;
            controls.maxDistance = 8;
            controls.enablePan = false;

            controls.addEventListener('start', () => {
                miningRate = isWarping ? 2.0 : 0.5;
            });
            controls.addEventListener('end', () => {
                miningRate = isWarping ? 1.0 : 0.1;
            });
        }

        function setupInteractivity() {
            raycaster = new THREE.Raycaster();
            window.addEventListener('mousedown', onMouseDown, false);
            window.addEventListener('mouseup', onMouseUp, false);
            document.getElementById('warpButton').addEventListener('click', toggleWarp);
            window.addEventListener('dblclick', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
            });

            // Start background music on first user interaction
            window.addEventListener('mousedown', playBackgroundMusic, { once: true });
            window.addEventListener('keydown', playBackgroundMusic, { once: true });
        }

        function onKeyDown(event) {
            if (event.code === 'Space') {
                toggleWarp();
            }
        }

        function onMouseDown(event) {
            glowMesh.material.uniforms.flare.value = 1.0;
            if (event.button === 0) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(earthMesh);
                if (intersects.length > 0) {
                    createScanEffect(intersects[0].point);
                    displayScanCoordinates(intersects[0].point);
                    playScanSound();
                    cameraShake(0.05, 200);
                    nairaCoin += 1.0;
                    updateCoinDisplay();
                }
            }
        }

        function onMouseUp() {
            glowMesh.material.uniforms.flare.value = 0.0;
        }

        function createScanEffect(position) {
            const scanGeometry = new THREE.TorusGeometry(0.01, 0.003, 32, 200);
            const scanMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff88, blending: THREE.AdditiveBlending, transparent: true });
            const scanner = new THREE.Mesh(scanGeometry, scanMaterial);
            scanner.position.copy(position);
            scanner.lookAt(new THREE.Vector3(0, 0, 0));
            earthMesh.add(scanner);

            let scale = 0.1;
            const animateScan = () => {
                scale += 0.05;
                scanner.scale.set(scale, scale, scale);
                scanMaterial.opacity = 1.0 - (scale / 8.0);
                if (scale < 8) {
                    requestAnimationFrame(animateScan);
                } else {
                    earthMesh.remove(scanner);
                }
            };
            animateScan();
        }

        function displayScanCoordinates(point) {
            const lat = 90 - (Math.acos(point.y / 0.6)) * 180 / Math.PI;
            const lon = ((270 + (Math.atan2(point.x, point.z)) * 180 / Math.PI) % 360) - 180;
            const coordsEl = document.getElementById('scan-coords');
            coordsEl.textContent = `SCAN COORDS: ${lat.toFixed(4)}, ${lon.toFixed(4)}`;
            coordsEl.style.opacity = '1';
            setTimeout(() => {
                coordsEl.style.opacity = '0';
            }, 5000);
        }

        function toggleWarp() {
            isWarping = !isWarping;
            document.getElementById('warpButton').textContent = isWarping ? 'Disengage Warp' : 'Engage Warp';
            miningRate = isWarping ? 1.0 : 0.1;
            nairaCoin += 2.0;
            updateCoinDisplay();
            updateWarpSound();
            cameraShake(0.1, 500);
        }

        function cameraShake(amplitude, duration) {
            const start = Date.now();
            const originalPos = camera.position.clone();
            const shake = () => {
                const elapsed = Date.now() - start;
                if (elapsed < duration) {
                    camera.position.x = originalPos.x + THREE.MathUtils.randFloat(-amplitude, amplitude);
                    camera.position.y = originalPos.y + THREE.MathUtils.randFloat(-amplitude, amplitude);
                    requestAnimationFrame(shake);
                } else {
                    camera.position.copy(originalPos);
                }
            };
            shake();
        }

        function updateCoinDisplay() {
            document.getElementById('naira-coin').textContent = nairaCoin.toFixed(2);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            nairaCoin += delta * miningRate;
            updateCoinDisplay();

            if (isWarping) {
                warpSpeed = THREE.MathUtils.lerp(warpSpeed, 10, delta * 0.5);
                starField.rotation.z += delta * warpSpeed;
                camera.position.z = THREE.MathUtils.lerp(camera.position.z, 3.0, delta * 0.2);
                camera.fov = THREE.MathUtils.lerp(camera.fov, 140, delta * 0.2);
                rgbShiftPass.uniforms.amount.value = THREE.MathUtils.lerp(rgbShiftPass.uniforms.amount.value, 0.005, delta);
                particleSystem.material.opacity = THREE.MathUtils.lerp(particleSystem.material.opacity, 1, delta);

                const positions = particleSystem.geometry.attributes.position.array;
                const velocities = particleSystem.geometry.attributes.velocity.array;
                for (let i = 0; i < positions.length / 3; i++) {
                    positions[i * 3 + 2] += velocities[i * 3 + 2] * delta * warpSpeed;
                    if (positions[i * 3 + 2] < -50) {
                        positions[i * 3 + 2] = 50;
                    }
                }
                particleSystem.geometry.attributes.position.needsUpdate = true;
            } else {
                warpSpeed = THREE.MathUtils.lerp(warpSpeed, 0, delta * 0.5);
                starField.rotation.z = THREE.MathUtils.lerp(starField.rotation.z, 0, delta * 0.2);
                camera.position.z = THREE.MathUtils.lerp(camera.position.z, 1.5, delta * 0.2);
                camera.fov = THREE.MathUtils.lerp(camera.fov, 75, delta * 0.2);
                rgbShiftPass.uniforms.amount.value = THREE.MathUtils.lerp(rgbShiftPass.uniforms.amount.value, 0.001, delta);
                particleSystem.material.opacity = THREE.MathUtils.lerp(particleSystem.material.opacity, 0, delta);
            }
            camera.updateProjectionMatrix();

            earthMesh.rotation.y += 0.001;
            cloudMesh.rotation.y += 0.0012;
            hexGridMesh.rotation.y += 0.0005;
            hexGridMesh.material.uniforms.time.value = time;
            glowMesh.rotation.y += 0.0005;
            glowMesh.material.uniforms.time.value = time;
            glowMesh.material.uniforms.flare.value = THREE.MathUtils.lerp(glowMesh.material.uniforms.flare.value, 0.0, delta * 3);

            satelliteGroup.children.forEach(sat => {
                const angle = time * sat.userData.orbitSpeed + sat.userData.phase;
                sat.position.x = Math.sin(angle) * sat.userData.orbitRadius;
                sat.position.z = Math.cos(angle) * sat.userData.orbitRadius;
                sat.position.y = Math.sin(angle * 0.5) * 0.3;
                sat.lookAt(earthMesh.position);
            });

            if (nairaSignsGroup) {
                nairaSignsGroup.children.forEach(sign => {
                    const angle = time * sign.userData.orbitSpeed + sign.userData.phase;
                    sign.position.x = Math.sin(angle) * sign.userData.orbitRadius;
                    sign.position.z = Math.cos(angle) * sign.userData.orbitRadius;
                    sign.position.y = Math.sin(angle * 0.8) * 0.5;
                    sign.rotation.y += 0.01;
                });
            }

            controls.update();
            composer.render();
        }

        init();
        animate();
    </script>

</body>
</html>   